---
name: Etapa 1.2 Servidor - Múltiplas Sessões
overview: Estender servidor para suportar múltiplas sessões concorrentes (max_games > 1) usando buffer produtor-consumidor com semáforos, thread anfitriã e max_games threads gestoras, cada uma gerindo uma sessão independente com seu próprio board_t.
todos:
  - id: srv2-1
    content: Criar estrutura connection_request_t com req_pipe_path[40] e notif_pipe_path[40]
    status: pending
  - id: srv2-2
    content: Criar estrutura connection_buffer_t com array de pedidos, head, tail, count, mutex, sem_t empty, sem_t full
    status: pending
    dependencies:
      - srv2-1
  - id: srv2-3
    content: "Inicializar buffer: mutex, sem_init(empty, max_games), sem_init(full, 0)"
    status: pending
    dependencies:
      - srv2-2
  - id: srv2-4
    content: Criar array de pthread_t session_manager_threads[max_games] e sessions[max_games]
    status: pending
  - id: srv2-5
    content: Criar função session_manager_thread_func() que extrai pedidos do buffer (sem_wait(full), mutex_lock, extrair, mutex_unlock, sem_post(empty))
    status: pending
    dependencies:
      - srv2-3
      - srv2-4
  - id: srv2-6
    content: "Na thread gestora: processar pedido (abrir pipes, enviar CONNECT, inicializar board_t, criar threads do jogo)"
    status: pending
    dependencies:
      - srv2-5
  - id: srv2-7
    content: Criar max_games threads gestoras na inicialização (pthread_create com índices 0 a max_games-1)
    status: pending
    dependencies:
      - srv2-5
  - id: srv2-8
    content: "Modificar host_thread_func(): inserir pedidos no buffer (sem_wait(empty), mutex_lock, inserir, mutex_unlock, sem_post(full))"
    status: pending
    dependencies:
      - srv2-3
  - id: srv2-9
    content: Cada sessão tem seu próprio board_t independente (alocar/carregar nível por sessão)
    status: pending
    dependencies:
      - srv2-6
  - id: srv2-10
    content: Modificar threads do jogo (pacman, ghost, board_update) para receber session_t* e usar session->board
    status: pending
    dependencies:
      - srv2-9
  - id: srv2-11
    content: "Implementar bloqueio: sem_wait(empty) bloqueia quando buffer cheio (max_games sessões ativas)"
    status: pending
    dependencies:
      - srv2-8
  - id: srv2-12
    content: "Quando sessão termina: sem_post(empty) para liberar slot e thread gestora volta a esperar"
    status: pending
    dependencies:
      - srv2-6
  - id: srv2-14
    content: "Implementar wraparound no buffer circular: (head+1) % max_size, (tail+1) % max_size"
    status: pending
    dependencies:
      - srv2-5
      - srv2-8
  - id: srv2-15
    content: "Limpar recursos: sem_destroy, mutex_destroy, pthread_join de todas threads gestoras"
    status: pending
    dependencies:
      - srv2-7
---

# Etapa 1.2 Serv

idor - Múltiplas Sessões

## Estrutura do Buffer Produtor-Consumidor

### 1. Criar estrutura connection_request_t

- **Arquivo**: `include/server.h` ou `include/threads.h`
- Definir `typedef struct connection_request_t` com:
- `char req_pipe_path[MAX_PIPE_PATH_LENGTH + 1]`
- `char notif_pipe_path[MAX_PIPE_PATH_LENGTH + 1]`
- Representa um pedido de conexão pendente

### 2. Criar estrutura connection_buffer_t

- **Arquivo**: `include/server.h` ou `include/threads.h`
- Definir `typedef struct connection_buffer_t` com:
- Array de `connection_request_t` (tamanho `max_games`)
- `int head` (índice para inserção - produtor)
- `int tail` (índice para extração - consumidor)
- `int count` (número de pedidos no buffer)
- `int max_size` (igual a `max_games`)
- `pthread_mutex_t mutex` (protege acesso ao buffer)
- `sem_t empty` (semáforo: conta slots vazios)
- `sem_t full` (semáforo: conta slots ocupados)

### 3. Inicializar buffer produtor-consumidor

- **Arquivo**: `src/server/game.c` (função no `main()` ou função dedicada)
- Criar instância global ou estática de `connection_buffer_t`
- Inicializar `head = 0`, `tail = 0`, `count = 0`, `max_size = max_games`
- Inicializar mutex: `pthread_mutex_init(&buffer.mutex, NULL)`
- Inicializar semáforo empty: `sem_init(&buffer.empty, 0, max_games)` (max_games slots vazios)
- Inicializar semáforo full: `sem_init(&buffer.full, 0, 0)` (0 slots ocupados inicialmente)

## Threads Gestoras (Session Manager Threads)

### 4. Criar array de threads gestoras

- **Arquivo**: `src/server/game.c` (variáveis globais/estáticas)
- Criar array `pthread_t session_manager_threads[max_games]`
- Criar array `session_t sessions[max_games]` para guardar info de cada sessão
- Criar no `main()` antes de criar thread anfitriã

### 5. Criar função session_manager_thread_func()

- **Arquivo**: `src/server/game.c`
- Receber índice da thread (0 a max_games-1) como argumento
- Loop infinito:
- Fazer `sem_wait(&buffer.full)` (bloqueia se buffer vazio)
- Fazer `pthread_mutex_lock(&buffer.mutex)`
- Extrair pedido do buffer (usar `tail`, incrementar, wraparound)
- Decrementar `count`
- Fazer `pthread_mutex_unlock(&buffer.mutex)`
- Fazer `sem_post(&buffer.empty)` (sinaliza slot vazio)
- Processar pedido de conexão

### 6. Processar pedido de conexão na thread gestora

- **Arquivo**: `src/server/game.c` (dentro de `session_manager_thread_func()`)
- Abrir pipes do cliente (`req_pipe_path` e `notif_pipe_path`)
- Enviar resposta CONNECT (OP_CODE=1 + result)
- Inicializar `board_t` para esta sessão (usar índice da thread)
- Guardar info na `sessions[thread_index]`
- Marcar sessão como ativa
- Criar threads do jogo para esta sessão (pacman, ghosts, board_update)

### 7. Criar max_games threads gestoras na inicialização

- **Arquivo**: `src/server/game.c` (função `main()`)
- Loop de 0 a `max_games-1`:
- Criar thread com `pthread_create(&session_manager_threads[i], NULL, session_manager_thread_func, &i)`
- Passar índice como argumento (usar `malloc` para evitar race condition)
- Threads ficam bloqueadas esperando pedidos no buffer

## Modificações na Thread Anfitriã

### 8. Modificar host_thread_func() para inserir no buffer

- **Arquivo**: `src/server/game.c`
- Quando receber mensagem CONNECT do pipe de registo:
- Ler `OP_CODE=1` + `req_pipe_path[40]` + `notif_pipe_path[40]`
- Criar `connection_request_t` com os paths
- Fazer `sem_wait(&buffer.empty)` (bloqueia se buffer cheio - max_games sessões ativas)
- Fazer `pthread_mutex_lock(&buffer.mutex)`
- Inserir pedido no buffer (usar `head`, incrementar, wraparound)
- Incrementar `count`
- Fazer `pthread_mutex_unlock(&buffer.mutex)`
- Fazer `sem_post(&buffer.full)` (sinaliza slot ocupado)
- Não processar conexão diretamente - apenas inserir no buffer

## Gestão de Sessões Independentes

### 9. Cada sessão tem seu próprio board_t

- **Arquivo**: `src/server/game.c`
- Modificar `session_t` para incluir `board_t* board`
- Quando thread gestora processa conexão:
- Alocar `board_t` com `malloc()` ou usar array pré-alocado
- Carregar nível inicial usando `load_level()`
- Associar `board_t` à `sessions[thread_index]`

### 10. Modificar threads do jogo para usar board da sessão

- **Arquivo**: `src/server/game.c`
- `pacman_thread_func()` deve receber `session_t*` em vez de `board_t*`
- Usar `session->board` para acessar tabuleiro
- `ghost_thread_func()` também recebe `session_t*`
- `board_update_thread_func()` também recebe `session_t*`
- Cada thread acessa apenas o board da sua sessão

### 11. Criar threads do jogo por sessão

- **Arquivo**: `src/server/game.c` (dentro de `session_manager_thread_func()`)
- Após estabelecer conexão e inicializar board:
- Criar `pacman_thread` para esta sessão
- Criar `ghost_threads` (um por ghost) para esta sessão
- Criar `board_update_thread` para esta sessão
- Guardar `pthread_t` na estrutura da sessão
- Fazer `pthread_join()` quando sessão terminar

## Bloqueio quando max_games sessões ativas

### 12. Implementar bloqueio automático

- **Arquivo**: `src/server/game.c` (função `host_thread_func()`)
- Quando `sem_wait(&buffer.empty)` é chamado:
- Se buffer está cheio (count == max_games), thread anfitriã bloqueia
- Quando uma sessão termina, `sem_post(&buffer.empty)` desbloqueia
- Thread anfitriã pode então inserir novo pedido

### 13. Liberar slot quando sessão termina

- **Arquivo**: `src/server/game.c` (quando sessão termina)
- Quando thread gestora detecta fim de sessão (desconexão ou jogo terminado):
- Fechar pipes e limpar recursos
- Marcar `sessions[thread_index].active = 0`
- Fazer `sem_post(&buffer.empty)` para liberar slot
- Thread gestora volta a esperar no buffer

## Sincronização e Thread Safety

### 14. Garantir thread safety no buffer

- **Arquivo**: `src/server/game.c`
- Todas as operações no buffer devem ser protegidas por mutex
- Semáforos garantem sincronização produtor-consumidor
- Verificar wraparound corretamente (head/tail voltam a 0 quando chegam a max_size)

## Limpeza e Terminação

### 15. Limpar recursos do buffer na terminação

- **Arquivo**: `src/server/game.c` (função de cleanup ou no final do `main()`)
- Fazer `pthread_mutex_destroy(&buffer.mutex)`
- Fazer `sem_destroy(&buffer.empty)`
- Fazer `sem_destroy(&buffer.full)`

### 16. Aguardar todas as threads gestoras terminarem

- **Arquivo**: `src/server/game.c` (no final do `main()` ou signal handler)
- Fazer `pthread_join()` para todas as `session_manager_threads[i]`
- Garantir que todas as sessões terminam antes de sair

## Notas de Implementação

- Buffer circular: usar `(head + 1) % max_size` e `(tail + 1) % max_size` para wraparound
- Semáforo `empty`: inicializado com `max_games` (todos os slots vazios inicialmente)
- Semáforo `full`: inicializado com 0 (nenhum slot ocupado inicialmente)
