---
name: Etapa 1.1 Servidor - Sessão Única
overview: Implementar servidor PacmanIST com suporte a uma única sessão de cliente (max_games=1), substituindo entrada de teclado por comunicação via named pipes e removendo display do servidor.
todos:
  - id: srv-1
    content: Criar estrutura session_t com req_pipe_fd, notif_pipe_fd, paths, board_t* e active flag
    status: pending
  - id: srv-2
    content: "Modificar main() para aceitar 3 argumentos: levels_dir, max_games, register_fifo_path"
    status: pending
  - id: srv-3
    content: Criar named pipe de registo com mkfifo() e abrir em modo leitura
    status: pending
    dependencies:
      - srv-2
  - id: srv-4
    content: Remover terminal_init() e terminal_cleanup() do main()
    status: pending
    dependencies:
      - srv-2
  - id: srv-5
    content: Criar host_thread_func() que lê do pipe de registo em loop
    status: pending
    dependencies:
      - srv-3
  - id: srv-6
    content: "Processar mensagem CONNECT: ler OP_CODE=1 + req_pipe_path[40] + notif_pipe_path[40]"
    status: pending
    dependencies:
      - srv-5
  - id: srv-7
    content: Abrir pipes do cliente no servidor (req em leitura, notif em escrita)
    status: pending
    dependencies:
      - srv-6
  - id: srv-8
    content: "Enviar resposta CONNECT: escrever OP_CODE=1 + result no notif_pipe"
    status: pending
    dependencies:
      - srv-7
  - id: srv-9
    content: Inicializar board_t para a sessão e marcar sessão como ativa
    status: pending
    dependencies:
      - srv-8
  - id: srv-10
    content: "Modificar pacman_thread_func(): ler OP_CODE e command do req_pipe em vez de get_input()"
    status: pending
    dependencies:
      - srv-9
  - id: srv-11
    content: Remover tratamento de comando G (quick save) conforme enunciado
    status: pending
    dependencies:
      - srv-10
  - id: srv-12
    content: Criar board_update_thread_func() que envia updates periódicos (a cada tempo)
    status: pending
    dependencies:
      - srv-9
  - id: srv-13
    content: "Serializar board_t: escrever OP_CODE=4 + width + height + tempo + victory + game_over + points + board_data"
    status: pending
    dependencies:
      - srv-12
  - id: srv-14
    content: Converter board->board[] para formato de mensagem (W→#, P→C, M→M/G, dots→., portal→@)
    status: pending
    dependencies:
      - srv-13
  - id: srv-15
    content: "Detectar desconexão: quando read() retorna 0/erro, marcar session.active=0 e limpar recursos"
    status: pending
    dependencies:
      - srv-10
  - id: srv-16
    content: "Processar OP_CODE_DISCONNECT (2): fechar pipes e limpar recursos da sessão"
    status: pending
    dependencies:
      - srv-10
  - id: srv-17
    content: Remover display_thread e todas chamadas a draw_board() do servidor
    status: pending
  - id: srv-18
    content: Remover includes de server_display.h e ncurses do game.c
    status: pending
    dependencies:
      - srv-17
---

# Etapa 1.1 Servidor - Sessão Única

## Estruturas e Headers

### 1. Criar estrutura session_t

- **Arquivo**: `include/server.h` (novo) ou `include/threads.h`
- Definir `typedef struct session_t` com:
- `int req_pipe_fd` (pipe de pedidos do cliente)
- `int notif_pipe_fd` (pipe de notificações do cliente)
- `char req_pipe_path[MAX_PIPE_PATH_LENGTH + 1]`
- `char notif_pipe_path[MAX_PIPE_PATH_LENGTH + 1]`
- `board_t* board` (tabuleiro da sessão)
- `int active` (flag de sessão ativa)
- Incluir `#include "protocol.h"` para OP_CODES

## Modificações no main()

### 2. Modificar assinatura de main()

- **Arquivo**: `src/server/game.c`
- Alterar de `main(int argc, char** argv)` para aceitar 3 argumentos:
- `argv[1]`: `levels_dir` (diretório de níveis)
- `argv[2]`: `max_games` (convertido com `atoi()`, deve ser 1 para Etapa 1.1)
- `argv[3]`: `register_fifo_path` (caminho do FIFO de registo)
- Validar `argc == 4`, retornar erro se não for

### 3. Criar named pipe de registo

- **Arquivo**: `src/server/game.c` (função `main()`)
- Chamar `mkfifo(register_fifo_path, 0640)` após validar argumentos
- Verificar erros (se pipe já existe, pode ignorar ou remover com `unlink()` primeiro)
- Abrir pipe de registo em modo leitura (`O_RDONLY`) e guardar file descriptor

### 4. Remover inicialização de display do main()

- **Arquivo**: `src/server/game.c`
- Remover chamada a `terminal_init()`
- Remover chamada a `terminal_cleanup()` no final
- Manter `open_debug_file()` e `close_debug_file()`

## Thread Anfitriã (Host Thread)

### 5. Criar função host_thread_func()

- **Arquivo**: `src/server/game.c`
- Receber `register_fifo_fd` como argumento (via struct)
- Loop infinito: ler do pipe de registo
- Quando receber dados, processar mensagem CONNECT

### 6. Processar mensagem CONNECT

- **Arquivo**: `src/server/game.c` (dentro de `host_thread_func()`)
- Ler `OP_CODE` (1 byte char) - deve ser `OP_CODE_CONNECT` (1)
- Ler `req_pipe_path[40]` (40 bytes)
- Ler `notif_pipe_path[40]` (40 bytes)
- Verificar se leitura foi completa

### 7. Abrir pipes do cliente no servidor

- **Arquivo**: `src/server/game.c` (dentro de `host_thread_func()`)
- Abrir `req_pipe_path` em modo leitura (`O_RDONLY`) - servidor lê comandos
- Abrir `notif_pipe_path` em modo escrita (`O_WRONLY`) - servidor envia updates
- Guardar file descriptors na estrutura `session_t`
- Verificar erros na abertura

### 8. Enviar resposta CONNECT

- **Arquivo**: `src/server/game.c` (dentro de `host_thread_func()`)
- Escrever `OP_CODE_CONNECT` (1 byte char) no `notif_pipe_fd`
- Escrever `result` (1 byte char): 0 = sucesso, != 0 = erro
- Verificar se escrita foi completa

### 9. Inicializar board_t para a sessão

- **Arquivo**: `src/server/game.c` (dentro de `host_thread_func()`)
- Carregar primeiro nível (usar lógica existente de `load_level()`)
- Associar `board_t` à `session_t`
- Marcar sessão como ativa

## Modificações na Thread do Pacman

### 10. Modificar pacman_thread_func() para ler de pipe

- **Arquivo**: `src/server/game.c`
- Remover chamada a `get_input()`
- Em vez disso, ler do `session.req_pipe_fd`:
- Ler `OP_CODE` (1 byte)
- Se `OP_CODE == OP_CODE_PLAY` (3), ler `command` (1 byte)
- Se `OP_CODE == OP_CODE_DISCONNECT` (2), terminar thread
- Se `read()` retornar 0 ou erro, detectar desconexão e terminar

### 11. Remover tratamento de comandos G e Q

- **Arquivo**: `src/server/game.c` (função `pacman_thread_func()`)
- Remover código que trata `'G'` (quick save) - conforme enunciado
- Manter tratamento de `'Q'` apenas se vier do cliente via pipe
- Remover `quick_save_requested` da lógica (mas manter na struct se necessário)

## Thread de Envio de Board Updates

### 12. Criar função board_update_thread_func()

- **Arquivo**: `src/server/game.c`
- Receber `session_t*` como argumento
- Loop: enquanto sessão ativa
- A cada `board->tempo` milissegundos, enviar update do board

### 13. Serializar board_t para mensagem

- **Arquivo**: `src/server/game.c` (dentro de `board_update_thread_func()`)
- Escrever `OP_CODE_BOARD` (1 byte char) no `notif_pipe_fd`
- Escrever `width` (int, 4 bytes)
- Escrever `height` (int, 4 bytes)
- Escrever `tempo` (int, 4 bytes)
- Escrever `victory` (int, 4 bytes) - calcular se portal foi alcançado
- Escrever `game_over` (int, 4 bytes) - calcular se pacman morreu
- Escrever `accumulated_points` (int, 4 bytes) - `board->pacmans[0].points`
- Converter `board->board[]` para array de chars:
- `'W'` → `'#'` (wall)
- `'P'` → `'C'` (pacman)
- `'M'` → `'M'` (ghost) ou `'G'` (ghost charged)
- `' '` com `has_dot` → `'.'`
- `' '` com `has_portal` → `'@'`
- `' '` vazio → `' '`
- Escrever `width * height` bytes (chars) do board serializado

### 14. Criar thread de board updates

- **Arquivo**: `src/server/game.c` (função `create_all_threads()` ou similar)
- Após estabelecer conexão, criar thread com `pthread_create()`
- Passar `session_t*` como argumento
- Guardar `pthread_t` para poder fazer `pthread_join()` depois

## Detecção de Desconexão

### 15. Detectar desconexão na thread do Pacman

- **Arquivo**: `src/server/game.c` (função `pacman_thread_func()`)
- Se `read()` retornar 0 ou erro negativo, cliente desconectou
- Marcar `session.active = 0`
- Sinalizar outras threads para terminarem
- Fechar pipes e limpar recursos

### 16. Detectar desconexão na thread de board updates

- **Arquivo**: `src/server/game.c` (função `board_update_thread_func()`)
- Se `write()` falhar (pipe fechado), cliente desconectou
- Marcar `session.active = 0`
- Terminar thread

## Processamento de DISCONNECT

### 17. Processar OP_CODE_DISCONNECT

- **Arquivo**: `src/server/game.c` (função `pacman_thread_func()`)
- Quando ler `OP_CODE_DISCONNECT` (2) do `req_pipe_fd`
- Marcar `session.active = 0`
- Fechar pipes (`close()`)
- Não enviar resposta (conforme protocolo)
- Limpar recursos da sessão

## Remoção de Display

### 18. Remover display_thread

- **Arquivo**: `src/server/game.c`
- Remover criação de `display_thread` em `create_all_threads()`
- Remover `display_thread_func()` ou deixar vazia
- Remover chamadas a `draw_board()` em todo o código
- Remover `pthread_join(display_thread, NULL)`

### 19. Remover includes de display

- **Arquivo**: `src/server/game.c`
- Remover `#include "server_display.h"`
- Remover `#include <ncurses.h>` se não for necessário

## Coordenação de Threads

### 20. Modificar create_all_threads() para receber session

- **Arquivo**: `src/server/game.c`
- Adicionar parâmetro `session_t*` à função
- Usar `session->board` em vez de `game_board` passado diretamente
- Criar threads apenas após conexão estabelecida

### 21. Modificar main() para usar thread anfitriã

- **Arquivo**: `src/server/game.c`
- Criar thread anfitriã antes do loop de níveis
- Thread anfitriã fica bloqueada esperando conexão
- Quando conexão estabelecida, carregar nível e iniciar jogo
- Após jogo terminar, voltar a esperar nova conexão (ou terminar se max_games=1)

## Notas de Implementação

- Todas as leituras/escritas de pipes devem verificar se foram completas
- Usar loops para garantir leitura completa de múltiplos bytes
- Tratar casos de pipe fechado (read/write retornam 0 ou erro)
- Garantir que apenas uma sessão está ativa (max_games=1)
- Se cliente desconectar, servidor deve voltar a aceitar nova conexão